{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# project: p2\n",
    "#submitter: rjfischer\n",
    "#partner: none"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import csv\n",
    "from zipfile import ZipFile\n",
    "from io import TextIOWrapper\n",
    "import pandas as pd\n",
    "import random\n",
    "import os, math\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#passes all tests\n",
    "class ZippedCSVReader:\n",
    "    def __init__(self,name):\n",
    "        self.paths=[]\n",
    "        self.filename=name\n",
    "        with ZipFile(name) as zf:\n",
    "            for info in zf.infolist():\n",
    "                self.paths.append(info.filename)\n",
    "        self.paths.sort()\n",
    "    def lines(self, name):\n",
    "        with ZipFile(self.filename) as zf:\n",
    "            with zf.open(name) as f:\n",
    "                for line in TextIOWrapper(f):\n",
    "                    yield line\n",
    "        \n",
    "    def csv_iter(self,CSVname=None):\n",
    "        if CSVname!=None:\n",
    "            with ZipFile(self.filename) as zf:\n",
    "                with zf.open(CSVname) as f:\n",
    "                    tio=TextIOWrapper(f)\n",
    "                    reader=csv.DictReader(tio)\n",
    "                    for row in reader:\n",
    "                        yield row\n",
    "        else:\n",
    "            for CSVname in self.paths:\n",
    "                with ZipFile(self.filename) as zf:\n",
    "                    with zf.open(CSVname,\"r\") as f:\n",
    "                        tio=TextIOWrapper(f)\n",
    "                        reader=csv.DictReader(tio)\n",
    "                        for row in reader:\n",
    "                            yield row\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_reader = ZippedCSVReader(\"mini.zip\")\n",
    "tree_reader = ZippedCSVReader(\"trees.zip\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Loan:\n",
    "    def __init__(self, amount, purpose, race, income, decision):\n",
    "        if amount=='' or amount==None:\n",
    "            self.amount=0\n",
    "        else:\n",
    "            self.amount=int(amount)\n",
    "        self.purpose=purpose\n",
    "        self.race=race\n",
    "        if income=='':\n",
    "            self.income=0\n",
    "        else:\n",
    "            self.income=int(income)\n",
    "        self.decision=decision\n",
    "        if self.race==\"White\":\n",
    "            self.White=1\n",
    "        else: \n",
    "            self.White=0\n",
    "        if self.race==\"Asian\":\n",
    "            self.Asian=1\n",
    "        else:\n",
    "            self.Asian=0\n",
    "        if self.race==\"Black or African American\":\n",
    "            self.Black_or_African_American=1\n",
    "        else:\n",
    "            self.Black_or_African_American=0\n",
    "        if self.race==\"Native Hawaiian or Other Pacific Islander\":\n",
    "            self.pacific_island=1\n",
    "        else:\n",
    "            self.pacific_island=0\n",
    "        if purpose==\"Refinancing\":\n",
    "            self.refin=1\n",
    "        else:\n",
    "            self.refin=0\n",
    "        if purpose==\"home_purchase\":\n",
    "            self.home_purchase==1\n",
    "        else:\n",
    "            self.home_purchase=0\n",
    "        if purpose==\"Home improvement\":\n",
    "            self.home_improv=1\n",
    "        else:\n",
    "            self.home_improv=0\n",
    "    def __repr__(self):\n",
    "        return(\"Loan({}, '{}', '{}', {}, '{}')\".format(self.amount,self.purpose,self.race,self.income,self.decision))\n",
    "\n",
    "    def __getitem__(self, lookup):\n",
    "        if lookup==\"amount\":\n",
    "            return self.amount\n",
    "        if lookup==\"purpose\":\n",
    "            return self.purpose\n",
    "        if lookup==\"race\":\n",
    "            return self.race\n",
    "        if lookup==\"income\":\n",
    "            return self.income\n",
    "        if lookup==\"decision\":\n",
    "            return self.decision\n",
    "        if lookup==\"White\":\n",
    "            return self.White\n",
    "        if lookup==\"Asian\":\n",
    "            return self.Asian\n",
    "        if lookup==\"Black or African American\":\n",
    "            return self.Black_or_African_American\n",
    "        if lookup==\"Native Hawaiian or Other Pacific Islander\":\n",
    "            return self.pacific_island\n",
    "        if lookup==\"Home purchase\":\n",
    "            return  self.home_purchase\n",
    "        if lookup==\"Refinance\" or lookup==\"Refinancing\":\n",
    "            if self.refin!=None:\n",
    "                return self.refin\n",
    "            else:\n",
    "                return 0\n",
    "        if lookup==\"Home improvement\":\n",
    "            return self.home_improv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_bank_names(reader):\n",
    "    bank_names=[]\n",
    "    for row in reader.csv_iter():\n",
    "        bank_names.append(row[\"agency_abbr\"])\n",
    "    bank_names=list(set(bank_names))\n",
    "    bank_names.sort()\n",
    "    return(bank_names)\n",
    "class Bank:\n",
    "    def __init__(self,agency_abbr,reader):\n",
    "        self.reader=reader\n",
    "        self.agency_abbr=agency_abbr\n",
    "        \n",
    "    def loan_iter(self):\n",
    "        for row in self.reader.csv_iter():\n",
    "            if self.agency_abbr==None:\n",
    "                row['respondent_id']=Loan(row[\"loan_amount_000s\"],row[\"loan_purpose\"], row[\"applicant_race_name_1\"], row[\"applicant_income_000s\"],row[\"action_taken_name\"])\n",
    "                yield row['respondent_id']\n",
    "            elif row[\"agency_abbr\"]==self.agency_abbr:\n",
    "                row['respondent_id']=Loan(row[\"loan_amount_000s\"],row[\"loan_purpose\"], row[\"applicant_race_name_1\"], row[\"applicant_income_000s\"],row[\"action_taken_name\"])\n",
    "                yield row['respondent_id']\n",
    "    \n",
    "    def loan_filter(self, loan_min, loan_max, loan_purpose):\n",
    "        for row in self.reader.csv_iter():\n",
    "            if row[\"loan_amount_000s\"]==\"\"or row[\"loan_purpose\"]==\"\":\n",
    "                pass\n",
    "            else:\n",
    "                if int(row[\"loan_amount_000s\"])>=loan_min&int(row[\"loan_amount_000s\"])<=loan_max&int(row[\"loan_purpose\"])==loan_purpose:\n",
    "                    yield row['respondednt_id']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "#passes all tests\n",
    "class SimplePredictor():\n",
    "    def __init__(self):\n",
    "        self.num_approved=0\n",
    "    \n",
    "    def predict(self, loan):\n",
    "        if loan[\"loan_purpose\"]==\"Home improvement\":\n",
    "            self.num_approved+=1\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "\n",
    "    def getApproved(self):\n",
    "        return self.num_approved"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "#class Node copied from https://tyler.caraza-harter.com/cs320/f20/reading/lec-12-search-trees.html\n",
    "from graphviz import Graph, Digraph\n",
    "\n",
    "class Node:\n",
    "    def __init__(self, val=None):\n",
    "        self.val = val\n",
    "        self.left = None\n",
    "        self.right = None\n",
    "    \n",
    "    def set_val(self,val):\n",
    "        self.val=val\n",
    "    \n",
    "    def to_graphviz(self, g=None):\n",
    "        if g == None:\n",
    "            g = Digraph()\n",
    "            \n",
    "        # draw self\n",
    "        g.node(repr(self.val))\n",
    "    \n",
    "        for label, child in [(\"L\", self.left), (\"R\", self.right)]:\n",
    "            if child != None:\n",
    "                # draw child, recursively\n",
    "                child.to_graphviz(g)\n",
    "                \n",
    "                # draw edge from self to child\n",
    "                g.edge(repr(self.val), repr(child.val), label=label)\n",
    "        return g\n",
    "    \n",
    "    def _repr_svg_(self):\n",
    "        return self.to_graphviz()._repr_svg_()\n",
    "\n",
    "class DTree(SimplePredictor):\n",
    "    def __init__(self):\n",
    "        SimplePredictor.__init__(self)\n",
    "        self.root=None\n",
    "        self.node_depths={}\n",
    "        self.num_disaproved=0\n",
    "        self.num_aproved=0\n",
    "    def readTree(self,reader, path):\n",
    "        self.root= Node()\n",
    "        self.node_depths[0]=[self.root]\n",
    "        \n",
    "        for line in reader.lines(path):\n",
    "            line=(line.split(\"---\"))\n",
    "            depth=(len(line[0].split(\"   \")))\n",
    "            line_attributes=line[1].split(\" \")\n",
    "            #reads in lines\n",
    "            \n",
    "            parent_name=line[1].split(\"<=\")\n",
    "            if len(parent_name) == 1:\n",
    "                parent_name=line[1].split(\">\")\n",
    "            parent_n=\"\"\n",
    "            for i in parent_name:\n",
    "                parent_n+=i\n",
    "            #This is the value of the nodes:example is (income 98.50).The values have 2 spaces inbetween variable name and number value\n",
    "            \n",
    "            parent=self.node_depths[depth-1][0]\n",
    "            #This is the path of the nodes:example is root.right.left.left\n",
    "            \n",
    "            if parent_n.strip()==\"class: 0\":\n",
    "            #if line_attributes[1]+line_attributes[-2].strip()==\"class:0\":\n",
    "                parent.set_val(\"class 0\")\n",
    "            elif parent_n.strip()==\"class: 1\":\n",
    "            #elif line_attributes[1]+line_attributes[-2].strip()==\"class:1\":\n",
    "                parent.set_val(\"class 1\")   \n",
    "            #if and elif for cases where node value is \"class: 0\" or \"class: 1\"\n",
    "                \n",
    "            elif line_attributes[-2]==\"<=\":\n",
    "                self.node_depths[depth-1]=[parent, parent.set_val(parent_n.strip())]\n",
    "                #self.node_depths[depth-1]=[parent, parent.set_val(line_attributes[1]+line_attributes[-2].strip())]\n",
    "                parent.left=Node()\n",
    "                self.node_depths[depth]=[parent.left]\n",
    "            elif line_attributes[-3]==\">\":\n",
    "                self.node_depths[depth-1]=[parent, parent.set_val(parent_n.strip())]\n",
    "                #self.node_depths[depth-1]=[parent, parent.set_val(line_attributes[1]+line_attributes[-2].strip())]\n",
    "                parent.right=Node()\n",
    "                self.node_depths[depth]=[parent.right]\n",
    "            #above 2 elif for creating nodes    \n",
    "            \n",
    "        return(self.root)  \n",
    "        \n",
    "    def predict(self,data,current_node=None):\n",
    "        if current_node==None:\n",
    "            current_node=self.root\n",
    "        loan_attribute=current_node.val.split(\"  \")[0]\n",
    "        loan_att_amount=current_node.val.split(\"  \")[-1]\n",
    "        \n",
    "        if loan_attribute==\"class 0\":\n",
    "            return(True)\n",
    "            self.num_aproved+=1\n",
    "        elif loan_attribute==\"class 1\":\n",
    "            self.num_disaproved+=1\n",
    "            return(False)\n",
    "        elif float(loan_att_amount)>data[loan_attribute]:\n",
    "            return(self.predict(data,current_node.left))\n",
    "        elif float(loan_att_amount)<=data[loan_attribute]:\n",
    "            return(self.predict(data,current_node.right))\n",
    "    def getDisapproved(self):\n",
    "        return self.num_disaproved\n",
    "    def getApproved(self):\n",
    "        return self.num_aproved\n",
    "    ### might need to flip around < and <= in predict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "loan = Loan(40, \"Home improvement\", \"Asian\", 120, \"approve\")\n",
    "tree_reader = ZippedCSVReader('trees.zip')\n",
    "dtree = DTree()\n",
    "dtree.readTree(tree_reader, \"bad.txt\")\n",
    "dtree.predict(loan)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "class RandomForest(SimplePredictor):\n",
    "    def __init__(self, trees):\n",
    "        self.trees=trees\n",
    "    def predict(self, loan):\n",
    "        total_approved=0\n",
    "        total_denied=0\n",
    "        for tree in self.trees:\n",
    "            if tree.predict(loan)==True:\n",
    "                total_approved+=1\n",
    "            else:\n",
    "                total_denied+=1\n",
    "        if total_approved>total_denied:\n",
    "            return True\n",
    "        else:\n",
    "            return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def bias_test(bank, predictor, race_override):\n",
    "    total_changed=0\n",
    "    total=0\n",
    "    for loan in bank.loan_iter():\n",
    "        #print(loan)\n",
    "        before= predictor.predict(loan)\n",
    "        new_loan=loan\n",
    "        new_loan.race=race_override\n",
    "        after=predictor.predict(new_loan)\n",
    "        if before==after:\n",
    "            pass\n",
    "        else:\n",
    "            total_change+=1\n",
    "        total+=1\n",
    "        #print(total_changed/total)\n",
    "    return (total_changed/total)\n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n"
     ]
    }
   ],
   "source": [
    "reader = ZippedCSVReader(\"loans.zip\")\n",
    "b = Bank(None, reader)\n",
    "\n",
    "tree_reader =ZippedCSVReader(\"trees.zip\")\n",
    "dtree =DTree()\n",
    "dtree.readTree(tree_reader, \"bad.txt\")\n",
    "bias_percent = bias_test(b, dtree, \"Black or African American\")\n",
    "print(bias_percent)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
